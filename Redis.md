## Redis

### 1.Redis是什么，其优缺点

Redis是一个NoSQL型数据库，使用键值对的方式存储数据，由于其特异的数据结构，以及将数据存放在内存的存储方式，Redis的性能非常出色，是目前已知性能最快的KEY-VALUE数据库，被广大公司广泛使用为缓存。

优点：

- 高效的读写性能，因为其对数据结构的优化，加上是在内存上的操作
- 支持数据持久化，有AOF(append only file 将数据库操作命令存储起来)和RDB(redis database 将目前存在的数据快照保存)。
- 丰富的数据结构，其数据结构有基础数据结构String, Hash, List, Set, ZSet和Geo(地理位置), HyperLogLog(基数统计), Bitmaps(位图)

缺点：

- 数据库容量受内存限制，无法处理海量数据的缓存(目前没有较好的解决办法) 可选的有，使用连接池减少连接数量，采用分布式集群扩展内存，换成pika基于SSD存储。

### 2. Redis数据结构底层

1. String字符串 采用sds,其结构如下，最大长度为512MB(redis 6.2.7 将最大长度设置为从文件中读取，意味着没有最大长度限制？)

   ![image-20240402215306228](img/sds.png)

   优势：

   1. 获取长度时间复杂度为O(1)    (使用len记录长度)
   2. 优化空间重分配次数(预分配空间策略(分配的空间往往大于字符串实际使用的空间) 和惰性空间释放机制(并不实际重新分配空间，而是用free记录不被使用的空间))
   3. 杜绝缓冲区溢出(增加长度时，若超出范围自动扩容)
   4. 二进制安全(不以/0判断字符串是否结束，而是以sds.len)

2. List列表 3.2版本之前使用ziplist(数据量小时使用)和linkedlist(数据量大时使用)作为底层数据结构，3.2之后使用quicklist

   > ziplist: 连续的链表，类似于数组，但每个元素的大小可以不同，使用prelength记录上一个元素的长度，使用encodeing标识本元素类型，确定其长度。存在连锁更新问题，即前一节点的长度变化，导致后一节点的prelength所需位数不足，扩充导致本节点长度变化，从而引起连锁反应。

   >quicklist: ziplist与linkedlist的结合体，本质是linkedlist,使用ziplist作为linkedlist的节点
   list阻塞命令实现底层原理：占用与客户端的连接，却不发消息。

3. Hash哈希(类似于java中的对象) 自定义hash结构，没发现什么特点，类似于LIst，底层在ziplist与hashtable依据数据具体选择。

4. Set集合 底层使用hashtable(使用键存元素)与intset

   > intset：特殊的整形数组，依据内部整数的大小，动态选择所用int的位数，采用分查找来检索元素


5. ZSet有序集合 采用listpack(数据量小以及数据长度小) 和skiplist dick实现

   > listpack：对于ziplist的优化，取消了前一字段的长度，改为记录本字段的长度。

   > skiplist：优化查找时间为logn，对链表的二分查找，实现方法，维护上下左右指针

   ![image-20240403113629013](img/skiplist.png)

### 3.Redis为什么速度快

1. 基于内存的操作，所有数据保存在内存中
2. 采用单线程，减少了多线程导致的开销，如线程的创建和销毁，以及线程的切换
3. 高效的自定义数据结构，sds，listpack，skiplist
4. IO多路复用

### 4.Redis为什么使用单线程

首先理解为什么普通基于IO的存储模式为什么要多线程，目前IO的操作一般都是DMA，采用DMA模式时，CPU遇到IO请求时，只需要通知DMA，后续的操作完全不需要CPU管，因此进行IO操作时CPU是空闲的，若使用单线程，CPU将会一直空闲直到IO完成，利用率大大下降，所以一般使用多线程，当当前线程IO时，切换到另一个线程执行。

但是redis是在内存上的操作，没有IO，所有操作都需要CPU参与，因此CPU利用率已经很高了。

当然对于多核处理器，采用多线程也确实能提升效率，既然单线程已经够用，为什么要设计更复杂的多线程呢。

其他原因：减少线程切换开销，不用加影响性能的锁。

### 5.缓存三大问题及解决方法

1. 缓存穿透             大量访问数据库中不存在的数据，导致数据库崩溃

   方法一：缓存空值。

   ​	缺陷：造成内存大量消耗

   方法二：使用布隆过滤器，对于不存在的数据直接返回

   ​	缺陷：存在误判，无法删除数据(采用计数型)

2.缓存雪崩         同一时间大量key过期导致

​	解决方法：热点key不过期，key过期时间随机分散。

3. 缓存击穿：     热点数据过期，同时有大量对该数据的访问

   解决办法：1.定时主动刷新 2.分布式锁 3.jvm锁 4.jvm缓存加redis缓存

### 6.缓存一致性问题

缓存更新方案就是删除缓存与更新数据库的组合排列，都有各自的缺陷，简单点且效果好的为先更新数据库，后删除缓存。

延迟双删：先删除缓存，后更新数据库，一段时间后再次删除缓存。

### 7.高并发

